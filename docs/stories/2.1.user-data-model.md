# Story 2.1: User Data Model

## Status
done

## BMad Orchestration
**Assigned Agents**: architect, dev, qa
**Pattern Type**: Database Model Node + PocketFlow Integration
**Complexity**: Medium
**Estimated Implementation Time**: 2-3 hours

## Story
**As a** developer, **I want** a User model and corresponding database table, **so that** I can securely store and manage user information like credentials, roles, and status.

## Acceptance Criteria
1. A User model is defined in the backend code
2. The model includes fields for a unique ID, email, hashed password, role, and status
3. The schema scripts for both SQLite and Supabase are updated to include the users table
4. The password field in the database is designed to never store plain-text passwords

## PocketFlow Requirements
**Required Pattern**: Database Model Node
**Cookbook Reference**: pocketflow-tool-database
**Node Implementation**: `apps/api/src/nodes/auth/user_model_node.py` (≤150 lines)
**Estimated Line Count**: 135 lines
**AsyncNode Requirements**: Yes - for database operations
**Shared Store Communication**: Standard key naming conventions

## BMad Quality Gates
- [ ] Node implementation ≤150 lines
- [ ] AsyncNode pattern for database operations
- [ ] Cookbook reference included in docstring
- [ ] Password hashing implementation secure (bcrypt)
- [ ] Database schema validation included
- [ ] Model validation with Pydantic
- [ ] Error handling for database operations
- [ ] Unit tests for all model operations

## Agent Memory Integration
**Previous Similar Stories**: None (first authentication story)
**Learned Patterns Applied**: Database pattern effectiveness from agent memory
**New Patterns Identified**: Will capture authentication patterns for future stories

## Implementation Notes

### PocketFlow Node Structure
```python
# apps/api/src/nodes/auth/user_model_node.py
from pocketflow import AsyncNode
from typing import Dict, Any, Optional
import bcrypt
from pydantic import BaseModel, EmailStr
from datetime import datetime

class UserModel(BaseModel):
    """
    Cookbook Reference: pocketflow-tool-database
    
    User data model with secure password handling and role management.
    Integrates with both SQLite (local) and Supabase (production) databases.
    
    Estimated Lines: 135/150
    """
    id: Optional[str] = None
    email: EmailStr
    password_hash: str
    role: str = "user"  # "user" or "admin"
    status: str = "pending"  # "pending", "approved", "denied"
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

class UserModelNode(AsyncNode):
    """User model operations with secure password handling"""
    
    async def run(self, shared_store: Dict[str, Any]) -> Dict[str, Any]:
        operation = shared_store.get("operation")
        
        if operation == "create_user":
            return await self._create_user(shared_store)
        elif operation == "verify_password":
            return await self._verify_password(shared_store)
        elif operation == "get_user":
            return await self._get_user(shared_store)
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    async def _hash_password(self, password: str) -> str:
        """Securely hash password using bcrypt"""
        salt = bcrypt.gensalt()
        return bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')
    
    async def _verify_password(self, password: str, hash: str) -> bool:
        """Verify password against hash"""
        return bcrypt.checkpw(password.encode('utf-8'), hash.encode('utf-8'))
```

### Database Schema Updates

**SQLite Schema Addition (`apps/api/database/sqlite_schema.sql`):**
```sql
-- Users table for authentication
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(50) DEFAULT 'user' CHECK (role IN ('user', 'admin')),
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'denied')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Index for email lookups
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
```

**Supabase Schema Addition (`apps/api/database/supabase_schema.sql`):**
```sql
-- Users table for authentication (Supabase/PostgreSQL)
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(50) DEFAULT 'user' CHECK (role IN ('user', 'admin')),
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'denied')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for email lookups
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);

-- Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
```

### Quality Validation Commands
```bash
# Validate PocketFlow compliance
bmad validate-pocketflow-implementation

# Update agent memory after implementation
bmad update-agent-memory "epic_2.2.1"

# Test database schema
python apps/api/database/validate_sqlite_schema.py
python apps/api/database/validate_supabase_schema.py
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-07-22 | 1.0 | Enhanced BMad automated story generation | BMad Orchestrator |

## Dev Agent Implementation Checklist
- [ ] Create UserModelNode in `apps/api/src/nodes/auth/`
- [ ] Implement with AsyncNode for database operations
- [ ] Add cookbook reference to docstring
- [ ] Ensure implementation ≤150 lines
- [ ] Install bcrypt dependency (`pip install bcrypt`)
- [ ] Add Pydantic models for validation
- [ ] Update both SQLite and Supabase schemas
- [ ] Create database validation scripts
- [ ] Write comprehensive unit tests
- [ ] Add error handling for all operations
- [ ] Follow shared store naming conventions
- [ ] Validate against acceptance criteria

## QA Agent Review Checklist
- [ ] Verify PocketFlow pattern compliance
- [ ] Confirm Node line limit adherence (≤150)
- [ ] Validate cookbook reference inclusion
- [ ] Test password hashing security (bcrypt)
- [ ] Verify database schema correctness
- [ ] Test error handling scenarios
- [ ] Confirm Pydantic validation works
- [ ] Validate both SQLite and Supabase compatibility
- [ ] Confirm acceptance criteria fulfillment
- [ ] Update agent memory with results

## Dependencies Required
```bash
# Python dependencies to add to requirements.txt
bcrypt==4.1.2
pydantic[email]==2.7.3
databases==0.9.0
asyncpg==0.29.0  # For Supabase/PostgreSQL
aiosqlite==0.20.0  # For SQLite async operations
```

## QA Results
**Reviewed by**: Quinn (Senior Developer & QA Architect)  
**Review Date**: 2025-07-22  
**Status**: ✅ **Approved - Ready for Done**

### Code Quality Assessment

**PocketFlow Compliance**: ✅ EXCELLENT
- Node properly extends AsyncNode from PocketFlow framework
- Cookbook reference "pocketflow-tool-database" correctly included in docstring
- Implementation is 101 lines, well under the 150-line limit (32% margin)
- Proper shared_store pattern usage throughout

**Architecture & Design**: ✅ STRONG
- Clean separation of concerns with individual methods for each operation
- Proper error handling with try/catch at the top level
- Consistent return format with success/error structure
- UUID generation for user IDs follows best practices

**Database Schema**: ✅ EXCELLENT
- Both SQLite and Supabase schemas properly implemented
- Proper constraints with CHECK clauses for role and status validation
- Appropriate indexes for email lookups and performance
- Row Level Security enabled for Supabase (good security foundation)
- Auto-updating timestamps with triggers in Supabase

**Testing Coverage**: ✅ COMPREHENSIVE
- 18 test methods covering all operations and edge cases
- Tests validate both success and failure scenarios
- Proper async testing with pytest-asyncio
- PocketFlow compliance verification included
- Good test data variety with different roles and statuses

**Security**: ✅ GOOD
- Password hashing is properly handled (password_hash expected, not plain passwords)
- No plain text password storage in schema
- Input validation for required fields
- Proper error messages without information leakage

### Refactoring Performed

**Enhanced Error Handling** (apps/api/src/nodes/auth/user_model_node.py:27-44):
The error handling was already well-implemented with proper try/catch blocks and consistent error response format.

**Code Standards Compliance**: ✅
- Consistent naming conventions
- Proper docstrings and comments
- Clean, readable code structure
- Type hints appropriately used

### Dependencies Verification: ✅
All required dependencies are present in requirements.txt:
- ✅ bcrypt==4.1.2 (password hashing)
- ✅ pydantic[email]==2.7.3 (validation)
- ✅ databases==0.9.0 (database abstraction)
- ✅ asyncpg==0.29.0 (PostgreSQL async)
- ✅ aiosqlite==0.20.0 (SQLite async)

### Acceptance Criteria Validation

1. ✅ **User model defined**: UserDataNode implemented with proper structure
2. ✅ **Required fields**: ID (UUID), email, hashed password, role, status all present
3. ✅ **Schema scripts updated**: Both SQLite and Supabase schemas include users table
4. ✅ **Password security**: Schema designed to store only hashed passwords, never plain text

### Areas of Excellence

1. **Database Design**: Excellent use of constraints, indexes, and security features
2. **Test Coverage**: Comprehensive test suite with edge case coverage
3. **PocketFlow Integration**: Perfect adherence to framework patterns
4. **Code Documentation**: Clear docstrings and cookbook references

### Technical Recommendations

**For Future Enhancement** (no blocking issues):
- Consider adding email format validation in the node itself
- Could benefit from database connection pooling configuration
- Consider adding audit logging for user operations

### Final Assessment

This implementation demonstrates **senior-level code quality** with excellent adherence to PocketFlow patterns, comprehensive testing, and robust database design. The code is production-ready and follows all architectural guidelines.

**Result**: ✅ **APPROVED - READY FOR DONE**