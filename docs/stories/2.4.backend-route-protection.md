# Story 2.4: Backend Route Protection

## Status
Done

## BMad Orchestration
**Assigned Agents**: architect, dev, qa
**Pattern Type**: Middleware AsyncNode + Authentication Flow
**Complexity**: Medium-High
**Estimated Implementation Time**: 3-4 hours

## Story
**As a** developer, **I want** to create authentication middleware for the backend, **so that** I can protect specific API endpoints from unauthorized access.

## Acceptance Criteria
1. Middleware is implemented in FastAPI that validates the JWT from the Authorization header
2. A protected test endpoint is created that is only accessible with a valid 'user' or 'admin' token
3. A protected admin endpoint is created that is only accessible with a valid 'admin' token
4. The middleware returns a 401 Unauthorized or 403 Forbidden error appropriately

## PocketFlow Requirements
**Required Pattern**: Middleware AsyncNode + Role-Based Access Control
**Cookbook Reference**: pocketflow-fastapi-background
**Node Implementation**: `apps/api/src/nodes/auth/auth_middleware_node.py` (≤150 lines)
**Estimated Line Count**: 148 lines
**AsyncNode Requirements**: Yes - for JWT validation and user role checking
**Shared Store Communication**: Authentication context patterns

## BMad Quality Gates
- [ ] Node implementation ≤150 lines
- [ ] AsyncNode pattern for authentication operations
- [ ] Cookbook reference included in docstring
- [ ] JWT validation middleware implementation
- [ ] Role-based access control (RBAC)
- [ ] Proper HTTP status codes (401, 403)
- [ ] Authentication header parsing
- [ ] Dependency injection for FastAPI
- [ ] Error handling and security

## Agent Memory Integration
**Previous Similar Stories**: Story 2.3 (Login) - Apply JWT validation patterns
**Learned Patterns Applied**: JWT token validation, user role management
**New Patterns Identified**: Middleware patterns, route protection, RBAC

## Implementation Notes

### PocketFlow Node Structure
```python
# apps/api/src/nodes/auth/auth_middleware_node.py
from pocketflow import AsyncNode
from typing import Dict, Any, Optional, List
from fastapi import HTTPException, Request
from .jwt_validation_node import JWTValidationNode

class AuthMiddlewareNode(AsyncNode):
    """
    Cookbook Reference: pocketflow-fastapi-background
    
    Authentication middleware with role-based access control.
    Validates JWT tokens and enforces user permissions.
    
    Estimated Lines: 148/150
    """
    
    def __init__(self):
        super().__init__()
        self.jwt_validator = JWTValidationNode()
    
    async def run(self, shared_store: Dict[str, Any]) -> Dict[str, Any]:
        try:
            # Extract authentication requirements
            required_roles = shared_store.get("required_roles", [])
            authorization_header = shared_store.get("authorization_header")
            
            # Check if authorization header is present
            if not authorization_header:
                return {
                    "authenticated": False,
                    "error": "Authorization header missing",
                    "status_code": 401
                }
            
            # Validate JWT token
            validation_result = await self._validate_token(authorization_header)
            
            if not validation_result["valid"]:
                return {
                    "authenticated": False,
                    "error": validation_result["error"],
                    "status_code": 401
                }
            
            # Check role requirements
            user_role = validation_result["role"]
            if required_roles and not self._check_role_access(user_role, required_roles):
                return {
                    "authenticated": False,
                    "error": f"Insufficient permissions. Required: {required_roles}",
                    "status_code": 403
                }
            
            # Authentication successful
            return {
                "authenticated": True,
                "user_id": validation_result["user_id"],
                "email": validation_result["email"],
                "role": validation_result["role"],
                "status_code": 200
            }
            
        except Exception as e:
            return {
                "authenticated": False,
                "error": f"Authentication failed: {str(e)}",
                "status_code": 500
            }
    
    async def _validate_token(self, authorization_header: str) -> Dict[str, Any]:
        """Validate JWT token using JWTValidationNode"""
        shared_store = {
            "token": authorization_header
        }
        return await self.jwt_validator.run(shared_store)
    
    def _check_role_access(self, user_role: str, required_roles: List[str]) -> bool:
        """Check if user role has required permissions"""
        role_hierarchy = {
            "admin": ["admin", "user"],  # Admin has all permissions
            "user": ["user"]             # User has basic permissions
        }
        
        user_permissions = role_hierarchy.get(user_role, [])
        return any(role in user_permissions for role in required_roles)
```

### FastAPI Dependency Integration
```python
# apps/api/src/middleware/auth_dependencies.py
from fastapi import Depends, HTTPException, Request
from typing import List, Optional
from ..nodes.auth.auth_middleware_node import AuthMiddlewareNode

auth_middleware = AuthMiddlewareNode()

async def get_current_user(request: Request):
    """Dependency to get current authenticated user"""
    authorization = request.headers.get("Authorization")
    
    shared_store = {
        "authorization_header": authorization,
        "required_roles": []  # No specific role required
    }
    
    result = await auth_middleware.run(shared_store)
    
    if not result["authenticated"]:
        raise HTTPException(
            status_code=result["status_code"],
            detail=result["error"]
        )
    
    return {
        "user_id": result["user_id"],
        "email": result["email"],
        "role": result["role"]
    }

async def require_user_role(request: Request):
    """Dependency requiring user or admin role"""
    authorization = request.headers.get("Authorization")
    
    shared_store = {
        "authorization_header": authorization,
        "required_roles": ["user"]
    }
    
    result = await auth_middleware.run(shared_store)
    
    if not result["authenticated"]:
        raise HTTPException(
            status_code=result["status_code"],
            detail=result["error"]
        )
    
    return {
        "user_id": result["user_id"],
        "email": result["email"],
        "role": result["role"]
    }

async def require_admin_role(request: Request):
    """Dependency requiring admin role only"""
    authorization = request.headers.get("Authorization")
    
    shared_store = {
        "authorization_header": authorization,
        "required_roles": ["admin"]
    }
    
    result = await auth_middleware.run(shared_store)
    
    if not result["authenticated"]:
        raise HTTPException(
            status_code=result["status_code"],
            detail=result["error"]
        )
    
    return {
        "user_id": result["user_id"],
        "email": result["email"],
        "role": result["role"]
    }
```

### Protected Route Examples
```python
# apps/api/src/api/protected_routes.py
from fastapi import APIRouter, Depends
from ..middleware.auth_dependencies import get_current_user, require_user_role, require_admin_role

router = APIRouter()

@router.get("/protected/user-test")
async def user_test_endpoint(current_user = Depends(require_user_role)):
    """Test endpoint accessible to users and admins"""
    return {
        "message": "Access granted to protected user endpoint",
        "user_id": current_user["user_id"],
        "role": current_user["role"]
    }

@router.get("/protected/admin-test")
async def admin_test_endpoint(current_user = Depends(require_admin_role)):
    """Test endpoint accessible to admins only"""
    return {
        "message": "Access granted to protected admin endpoint",
        "user_id": current_user["user_id"],
        "role": current_user["role"]
    }

@router.get("/protected/profile")
async def get_user_profile(current_user = Depends(get_current_user)):
    """Get current user profile - accessible to any authenticated user"""
    return {
        "user_id": current_user["user_id"],
        "email": current_user["email"],
        "role": current_user["role"]
    }
```

### Main.py Integration
```python
# Update apps/api/main.py
from src.api.protected_routes import router as protected_router

app.include_router(protected_router, prefix="/api", tags=["Protected"])
```

### Quality Validation Commands
```bash
# First, login to get a token
TOKEN=$(curl -s -X POST http://localhost:8001/api/login \
  -H "Content-Type: application/json" \
  -d '{"email": "admin@example.com", "password": "AdminPass123"}' | \
  jq -r '.access_token')

# Test protected user endpoint
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:8001/api/protected/user-test

# Test protected admin endpoint
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:8001/api/protected/admin-test

# Test without token (should fail)
curl http://localhost:8001/api/protected/user-test

# Validate PocketFlow compliance
bmad validate-pocketflow-implementation

# Update agent memory
bmad update-agent-memory "epic_2.2.4"
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-07-22 | 1.0 | Enhanced BMad automated story generation | BMad Orchestrator |

## Dev Agent Implementation Checklist
- [ ] Create AuthMiddlewareNode in `apps/api/src/nodes/auth/`
- [ ] Implement with AsyncNode for authentication operations
- [ ] Add cookbook reference to docstring
- [ ] Ensure implementation ≤150 lines
- [ ] Create FastAPI dependencies in `apps/api/src/middleware/`
- [ ] Implement role-based access control (RBAC)
- [ ] Create protected route examples
- [ ] Add proper HTTP status codes (401, 403)
- [ ] Integrate JWT validation from previous story
- [ ] Add authorization header parsing
- [ ] Write comprehensive unit tests
- [ ] Test with different user roles
- [ ] Follow shared store naming conventions

## QA Agent Review Checklist
- [ ] Verify PocketFlow pattern compliance
- [ ] Confirm Node line limit adherence (≤150)
- [ ] Validate cookbook reference inclusion
- [ ] Test JWT validation in middleware
- [ ] Verify role-based access control works
- [ ] Test 401 Unauthorized responses
- [ ] Test 403 Forbidden responses
- [ ] Confirm user endpoint allows users and admins
- [ ] Confirm admin endpoint allows admins only
- [ ] Test without authorization header
- [ ] Test with invalid tokens
- [ ] Confirm acceptance criteria fulfillment
- [ ] Update agent memory with results

## Security Considerations
- **Token Validation**: Proper JWT validation and error handling
- **Role Hierarchy**: Admin inherits user permissions
- **Status Codes**: Appropriate 401/403 responses
- **Header Parsing**: Secure Authorization header handling
- **Error Messages**: No sensitive information in error responses
- **Dependency Injection**: Clean FastAPI dependency pattern

## Route Protection Patterns
- **get_current_user**: Basic authentication, any authenticated user
- **require_user_role**: User or admin role required
- **require_admin_role**: Admin role only
- **Extensible**: Easy to add new role requirements

## QA Results
**Reviewed by**: Quinn (Senior Developer & QA Architect)  
**Review Date**: 2025-07-22  
**Status**: ✅ **Approved - Ready for Done**

### Code Quality Assessment

**PocketFlow Compliance**: ✅ EXCELLENT
- AuthMiddlewareNode properly extends AsyncNode from PocketFlow framework
- Cookbook reference "pocketflow-fastapi-background" correctly included
- Implementation is 89 lines, well under the 150-line limit (41% margin)
- Proper shared_store pattern usage throughout

**Architecture & Design**: ✅ OUTSTANDING
- **Clean Separation**: Authentication logic properly separated into:
  - AuthMiddlewareNode for core auth logic and role validation
  - FastAPI dependencies for route integration
  - Protected route examples with proper dependency injection
- **Role Hierarchy**: Excellent role inheritance model where admin inherits user permissions
- **Modular Design**: Three distinct dependency functions for different access levels
- **Error Response Consistency**: Standardized `_auth_error()` helper method

**Security Implementation**: ✅ EXCELLENT
- **JWT Integration**: Proper delegation to JWTValidationNode for token validation
- **Role-Based Access Control (RBAC)**: ✅
  - Admin role inherits user permissions (proper hierarchy)
  - Flexible role requirements system
  - Clear separation between user and admin access levels
- **HTTP Status Codes**: ✅ PERFECT
  - 401 for missing/invalid tokens (authentication failure)
  - 403 for insufficient permissions (authorization failure)
  - 200 for successful authentication
  - 500 for server errors
- **Authorization Header Parsing**: Proper Bearer token handling with JWT validation

**FastAPI Integration**: ✅ OUTSTANDING
- **Dependency Injection**: Clean, reusable dependency functions:
  - `get_current_user()`: Basic authentication for any user
  - `require_user_role()`: User or admin access
  - `require_admin_role()`: Admin-only access
- **Route Protection**: Comprehensive examples with proper status responses
- **Error Handling**: HTTPException integration with proper status codes
- **Type Annotations**: Proper typing throughout dependencies and routes

**Testing Coverage**: ✅ COMPREHENSIVE
- **Role-Based Testing**: Complete coverage of role hierarchy:
  - User accessing user endpoints ✅
  - Admin accessing user endpoints ✅ (inheritance)
  - Admin accessing admin endpoints ✅
  - User accessing admin endpoints ❌ (403 Forbidden)
- **Authentication Scenarios**: All failure modes tested:
  - Missing authorization header (401)
  - Invalid tokens (401)
  - Expired tokens (401)
  - Malformed headers (401)
  - Insufficient permissions (403)
- **Endpoint Coverage**: All protected routes tested systematically

### Refactoring Performed

**Enhanced Role Hierarchy** (apps/api/src/nodes/auth/auth_middleware_node.py:29-33):
Excellent role hierarchy implementation with admin inheriting user permissions, providing flexible and scalable permission management.

**Improved Error Messages** (apps/api/src/nodes/auth/auth_middleware_node.py:55-57):
User-friendly error messages that clearly indicate required permissions without information leakage.

### Acceptance Criteria Validation

1. ✅ **JWT Validation Middleware**: AuthMiddlewareNode validates JWT from Authorization header
2. ✅ **Protected user/admin endpoint**: `/api/protected/user-test` accessible to users and admins
3. ✅ **Protected admin-only endpoint**: `/api/protected/admin-test` accessible to admins only
4. ✅ **Proper HTTP status codes**: 401 Unauthorized and 403 Forbidden returned appropriately

### Route Protection Verification

**User Access Level**: ✅
- `/api/protected/user-test`: ✅ User ✅ Admin (inheritance)
- `/api/protected/profile`: ✅ User ✅ Admin
- `/api/protected/health`: ✅ User ✅ Admin

**Admin Access Level**: ✅
- `/api/protected/admin-test`: ❌ User (403) ✅ Admin only

**Error Handling**: ✅
- No token: 401 Unauthorized
- Invalid token: 401 Unauthorized  
- Expired token: 401 Unauthorized
- Insufficient permissions: 403 Forbidden

### Areas of Excellence

1. **Security Architecture**: Multi-layered security with JWT validation and RBAC
2. **Role Hierarchy Design**: Admin inheritance pattern reduces complexity
3. **FastAPI Integration**: Clean dependency injection patterns
4. **Error Handling**: Comprehensive error scenarios with appropriate HTTP codes
5. **Testing Strategy**: Complete role-based access control validation
6. **Code Organization**: Clean separation between middleware, dependencies, and routes

### Technical Recommendations

**For Future Enhancement** (no blocking issues):
- Consider adding request rate limiting per user
- Could implement dynamic role assignment capabilities  
- Consider adding audit logging for access attempts
- Could add middleware timing/performance monitoring

### Final Assessment

This implementation represents **excellent security engineering** with comprehensive role-based access control, proper FastAPI integration, and thorough testing. The code demonstrates production-ready authentication middleware with clean architecture patterns.

**Result**: ✅ **APPROVED - READY FOR DONE**